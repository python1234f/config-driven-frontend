===============================

Jesteś agentem developerskim w IntelliJ. Zbootstrappuj projekt frontendowy React (JS, bez TypeScript na start).
Cel: małe demo architektury modularnego frontendu dla przemysłu (rafinerie ropy/gazu).
Nie budujemy produktu. Budujemy koncepcyjny proof, że frontend jest client-agnostic i konfigurowalny między klientami bez forka kodu.

Kontekst domeny:
- System AI analizuje dane z czujników (ciśnienie, temperatura, przepływ, poziomy, trendy) i generuje decyzje/alerty.
- Operator nie patrzy w UI non-stop. UI służy do wyjaśnienia decyzji AI (explainability), audytu i post-mortem.
- Klienci różnią się instalacjami, namingiem sygnałów, modelami alarmów, SLA/compliance -> frontend ma być wspólny, tylko config inny.

Wymagania architektury:
1) Konfigurowalność między klientami: zmiana klienta = zmiana ClientConfig (plik JS), bez ifów typu `if (client === ...)`.
2) Feature gating: komponent FeatureGate renderuje feature’y na podstawie capabilities z configu. Zero ifów per klient w UI.
3) Domain adapters: adapter mapuje surowe eventy klienta do `NormalizedDecision` (kontrakt domenowy). UI zna tylko normalizowany kontrakt.
4) Graceful degradation: obsłuż brak danych, stale data, low confidence (UI ma być „boring but honest”).
5) Debug-first: dodaj dużo console.log (spójne prefixy). Loguj config, features, normalizedDecision, przepływ danych.
6) JS-first: brak TypeScript teraz. Używaj JSDoc w /domain żeby było TS-ready później.

Zbuduj:
- Układ: lewa kolumna „Client Config Panel” (dropdowny + minimalny JSON view) + przycisk „Simulate client” (losuje poprawny config),
  prawa kolumna „Decision Inspector”: lista decyzji (Decision History) + panel szczegółów decyzji (Decision Details).
- Dwa przykładowe klient-configi (clientA i clientB) różniące się: units, alarmModel, features (np. aiConfidence on/off, decisionHistory on/off).
- Przykładowe dane decyzji (mock) per klient, przechodzące przez adapter do NormalizedDecision.

Pliki/artefakty: